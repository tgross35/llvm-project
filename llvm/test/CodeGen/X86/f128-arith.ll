; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s -mtriple=i686-unknown-unknown   -verify-machineinstrs | FileCheck %s --check-prefix=CHECK-32
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -verify-machineinstrs | FileCheck %s --check-prefix=CHECK-64
;
; Test lowering of fp128 intrinsics
; FIXME: these emit calls to long double functions but should emit f128 calls

define fp128 @test_cbrtf128(fp128 %a) {
; CHECK-32-LABEL: test_cbrtf128:
; CHECK-32:    calll llvm.cbrt.f128@PLT
;
; CHECK-64-LABEL: test_cbrtf128:
; CHECK-64:    jmp llvm.cbrt.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.cbrt.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.cbrt.f128(fp128)


define fp128 @test_ceilf128(fp128 %a) {
; CHECK-32-LABEL: test_ceilf128:
; CHECK-32:    calll ceill
;
; CHECK-64-LABEL: test_ceilf128:
; CHECK-64:    jmp ceill@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.ceil.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.ceil.f128(fp128)


define fp128 @test_copysignf128(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test_copysignf128:
; CHECK-32:       # %bb.0: # %start
; CHECK-32-NEXT:    pushl %ebx
; CHECK-32-NEXT:    .cfi_def_cfa_offset 8
; CHECK-32-NEXT:    pushl %edi
; CHECK-32-NEXT:    .cfi_def_cfa_offset 12
; CHECK-32-NEXT:    pushl %esi
; CHECK-32-NEXT:    .cfi_def_cfa_offset 16
; CHECK-32-NEXT:    .cfi_offset %esi, -16
; CHECK-32-NEXT:    .cfi_offset %edi, -12
; CHECK-32-NEXT:    .cfi_offset %ebx, -8
; CHECK-32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK-32-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CHECK-32-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK-32-NEXT:    movl $-2147483648, %edi # imm = 0x80000000
; CHECK-32-NEXT:    andl {{[0-9]+}}(%esp), %edi
; CHECK-32-NEXT:    movl $2147483647, %ebx # imm = 0x7FFFFFFF
; CHECK-32-NEXT:    andl {{[0-9]+}}(%esp), %ebx
; CHECK-32-NEXT:    orl %edi, %ebx
; CHECK-32-NEXT:    movl %ebx, 12(%eax)
; CHECK-32-NEXT:    movl %esi, 8(%eax)
; CHECK-32-NEXT:    movl %edx, 4(%eax)
; CHECK-32-NEXT:    movl %ecx, (%eax)
; CHECK-32-NEXT:    popl %esi
; CHECK-32-NEXT:    .cfi_def_cfa_offset 12
; CHECK-32-NEXT:    popl %edi
; CHECK-32-NEXT:    .cfi_def_cfa_offset 8
; CHECK-32-NEXT:    popl %ebx
; CHECK-32-NEXT:    .cfi_def_cfa_offset 4
; CHECK-32-NEXT:    retl $4
;
; CHECK-64-LABEL: test_copysignf128:
; CHECK-64:       # %bb.0: # %start
; CHECK-64-NEXT:    andps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1
; CHECK-64-NEXT:    andps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
; CHECK-64-NEXT:    orps %xmm1, %xmm0
; CHECK-64-NEXT:    retq
; FIXME: calling long double rather than f128 function
; FIXME: calling long double rather than f128 function
start:
  %0 = tail call fp128 @llvm.copysign.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.copysign.f128(fp128, fp128)


define fp128 @test_cosf128(fp128 %a) {
; CHECK-32-LABEL: test_cosf128:
; CHECK-32:    calll cosl
;
; CHECK-64-LABEL: test_cosf128:
; CHECK-64:    jmp cosl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.cos.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.cos.f128(fp128)


define fp128 @test_exp2f128(fp128 %a) {
; CHECK-32-LABEL: test_exp2f128:
; CHECK-32:    calll exp2l
;
; CHECK-64-LABEL: test_exp2f128:
; CHECK-64:    jmp exp2l@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.exp2.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.exp2.f128(fp128)


define fp128 @test___exp2f128_finite(fp128 %a) {
; CHECK-32-LABEL: test___exp2f128_finite:
; CHECK-32:    calll llvm.__exp2f128_finite.f128@PLT
;
; CHECK-64-LABEL: test___exp2f128_finite:
; CHECK-64:    jmp llvm.__exp2f128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__exp2f128_finite.f128(fp128  %a)
  ret fp128 %0
}

declare fp128 @llvm.__exp2f128_finite.f128(fp128)


define fp128 @test_expf128(fp128 %a) {
; CHECK-32-LABEL: test_expf128:
; CHECK-32:    calll expl
;
; CHECK-64-LABEL: test_expf128:
; CHECK-64:    jmp expl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.exp.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.exp.f128(fp128)


define fp128 @test___expf128_finite(fp128 %a) {
; CHECK-32-LABEL: test___expf128_finite:
; CHECK-32:    calll llvm.__expf128_finite.f128@PLT
;
; CHECK-64-LABEL: test___expf128_finite:
; CHECK-64:    jmp llvm.__expf128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__expf128_finite.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.__expf128_finite.f128(fp128)


define fp128 @test_floorf128(fp128 %a) {
; CHECK-32-LABEL: test_floorf128:
; CHECK-32:    calll floorl
;
; CHECK-64-LABEL: test_floorf128:
; CHECK-64:    jmp floorl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.floor.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.floor.f128(fp128)


define fp128 @test_fmaf128(fp128 %a, fp128 %b, fp128 %c) {
; CHECK-32-LABEL: test_fmaf128:
; CHECK-32:    calll fmal
;
; CHECK-64-LABEL: test_fmaf128:
; CHECK-64:    jmp fmal@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.fma.f128(fp128 %a, fp128 %b, fp128 %c)
  ret fp128 %0
}

declare fp128 @llvm.fma.f128(fp128, fp128, fp128)


define fp128 @test_fmaxf128(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test_fmaxf128:
; CHECK-32:    calll llvm.fmax.f128@PLT
;
; CHECK-64-LABEL: test_fmaxf128:
; CHECK-64:    jmp llvm.fmax.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.fmax.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.fmax.f128(fp128, fp128)


define fp128 @test_fminf128(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test_fminf128:
; CHECK-32:    calll llvm.fmin.f128@PLT
;
; CHECK-64-LABEL: test_fminf128:
; CHECK-64:    jmp llvm.fmin.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.fmin.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.fmin.f128(fp128, fp128)


define fp128 @test_fmodf128(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test_fmodf128:
; CHECK-32:    calll llvm.fmod.f128@PLT
;
; CHECK-64-LABEL: test_fmodf128:
; CHECK-64:    jmp llvm.fmod.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.fmod.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.fmod.f128(fp128, fp128)


define { fp128, i32 } @test_frexpf128(fp128 %a) {
; CHECK-32-LABEL: test_frexpf128:
; CHECK-32:    calll frexpl
;
; CHECK-64-LABEL: test_frexpf128:
; CHECK-64:    callq frexpl@PLT
start:
  %0 = tail call { fp128, i32 } @llvm.frexp.f128(fp128 %a)
  ret { fp128, i32 } %0
}

declare { fp128, i32 } @llvm.frexp.f128(fp128)


define fp128 @test_ldexpf128(fp128 %a, i32 %b) {
; CHECK-32-LABEL: test_ldexpf128:
; CHECK-32:    calll ldexpl
;
; CHECK-64-LABEL: test_ldexpf128:
; CHECK-64:    jmp ldexpl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.ldexp.f128(fp128 %a, i32 %b)
  ret fp128 %0
}

declare fp128 @llvm.ldexp.f128(fp128, i32)


define i64 @test_llrintf128(fp128 %a) {
; CHECK-32-LABEL: test_llrintf128:
; CHECK-32:    calll llrintl
;
; CHECK-64-LABEL: test_llrintf128:
; CHECK-64:    jmp llrintl@PLT # TAILCALL
start:
  %0 = tail call i64 @llvm.llrint.f128(fp128 %a)
  ret i64 %0
}

declare i64 @llvm.llrint.f128(fp128)


define i64 @test_llroundf128(fp128 %a) {
; CHECK-32-LABEL: test_llroundf128:
; CHECK-32:    calll llroundl
;
; CHECK-64-LABEL: test_llroundf128:
; CHECK-64:    jmp llroundl@PLT # TAILCALL
start:
  %0 = tail call i64 @llvm.llround.i64.f128(fp128 %a)
  ret i64 %0
}

declare i64 @llvm.llround.i64.f128(fp128)


define fp128 @test_log10f128(fp128 %a) {
; CHECK-32-LABEL: test_log10f128:
; CHECK-32:    calll log10l
;
; CHECK-64-LABEL: test_log10f128:
; CHECK-64:    jmp log10l@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.log10.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.log10.f128(fp128)


define fp128 @test___log10f128_finite(fp128 %a) {
; CHECK-32-LABEL: test___log10f128_finite:
; CHECK-32:    calll llvm.__log10f128_finite.f128@PLT
;
; CHECK-64-LABEL: test___log10f128_finite:
; CHECK-64:    jmp llvm.__log10f128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__log10f128_finite.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.__log10f128_finite.f128(fp128)


define fp128 @test_log2f128(fp128 %a) {
; CHECK-32-LABEL: test_log2f128:
; CHECK-32:    calll log2l
;
; CHECK-64-LABEL: test_log2f128:
; CHECK-64:   jmp log2l@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.log2.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.log2.f128(fp128)


define fp128 @test___log2f128_finite(fp128 %a) {
; CHECK-32-LABEL: test___log2f128_finite:
; CHECK-32:    calll llvm.__log2f128_finite.f128@PLT
;
; CHECK-64-LABEL: test___log2f128_finite:
; CHECK-64:    jmp llvm.__log2f128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__log2f128_finite.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.__log2f128_finite.f128(fp128)


define fp128 @test_logf128(fp128 %a) {
; CHECK-32-LABEL: test_logf128:
; CHECK-32:    calll logl
;
; CHECK-64-LABEL: test_logf128:
; CHECK-64:    jmp logl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.log.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.log.f128(fp128)


define fp128 @test___logf128_finite(fp128 %a) {
; CHECK-32-LABEL: test___logf128_finite:
; CHECK-32:    calll llvm.__logf128_finite.f128@PLT
;
; CHECK-64-LABEL: test___logf128_finite:
; CHECK-64:    jmp llvm.__logf128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__logf128_finite.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.__logf128_finite.f128(fp128)


define i64 @test_lrintf128(fp128 %a) {
; CHECK-32-LABEL: test_lrintf128:
; CHECK-32:    calll lrintl
;
; CHECK-64-LABEL: test_lrintf128:
; CHECK-64:    jmp lrintl@PLT # TAILCALL
start:
  %0 = tail call i64 @llvm.lrint.f128(fp128 %a)
  ret i64 %0
}

declare i64 @llvm.lrint.f128(fp128)


define i64 @test_lroundf128(fp128 %a) {
; CHECK-32-LABEL: test_lroundf128:
; CHECK-32:    calll lroundl
;
; CHECK-64-LABEL: test_lroundf128:
; CHECK-64:    jmp lroundl@PLT # TAILCALL
start:
  %0 = tail call i64 @llvm.lround.i64.f128(fp128 %a)
  ret i64 %0
}

declare i64 @llvm.lround.i64.f128(fp128)


define fp128 @test_nearbyintf128(fp128 %a) {
; CHECK-32-LABEL: test_nearbyintf128:
; CHECK-32:    calll nearbyintl
;
; CHECK-64-LABEL: test_nearbyintf128:
; CHECK-64:    jmp nearbyintl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.nearbyint.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.nearbyint.f128(fp128)


define fp128 @test_powf128(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test_powf128:
; CHECK-32:    calll powl
;
; CHECK-64-LABEL: test_powf128:
; CHECK-64:    jmp powl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.pow.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.pow.f128(fp128, fp128)


define fp128 @test___powf128_finite(fp128 %a, fp128 %b) {
; CHECK-32-LABEL: test___powf128_finite:
; CHECK-32:    calll llvm.__powf128_finite.f128@PLT
;
; CHECK-64-LABEL: test___powf128_finite:
; CHECK-64:    jmp llvm.__powf128_finite.f128@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.__powf128_finite.f128(fp128 %a, fp128 %b)
  ret fp128 %0
}

declare fp128 @llvm.__powf128_finite.f128(fp128, fp128)


define fp128 @test_rintf128(fp128 %a) {
; CHECK-32-LABEL: test_rintf128:
; CHECK-32:    calll rintl
;
; CHECK-64-LABEL: test_rintf128:
; CHECK-64:    jmp rintl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.rint.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.rint.f128(fp128)


define fp128 @test_roundevenf128(fp128 %a) {
; CHECK-32-LABEL: test_roundevenf128:
; CHECK-32:    calll roundevenl
;
; CHECK-64-LABEL: test_roundevenf128:
; CHECK-64:    jmp roundevenl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.roundeven.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.roundeven.f128(fp128)


define fp128 @test_roundf128(fp128 %a) {
; CHECK-32-LABEL: test_roundf128:
; CHECK-32:    calll roundl
;
; CHECK-64-LABEL: test_roundf128:
; CHECK-64:    jmp roundl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.round.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.round.f128(fp128)


define fp128 @test_sinf128(fp128 %a) {
; CHECK-32-LABEL: test_sinf128:
; CHECK-32:    calll sinl
;
; CHECK-64-LABEL: test_sinf128:
; CHECK-64:    jmp sinl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.sin.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.sin.f128(fp128)


define fp128 @test_sqrtf128(fp128 %a) {
; CHECK-32-LABEL: test_sqrtf128:
; CHECK-32:    calll sqrtl
;
; CHECK-64-LABEL: test_sqrtf128:
; CHECK-64:    jmp sqrtl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.sqrt.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.sqrt.f128(fp128)


define fp128 @test_truncf128(fp128 %a) {
; CHECK-32-LABEL: test_truncf128:
; CHECK-32:    calll truncl
;
; CHECK-64-LABEL: test_truncf128:
; CHECK-64:    jmp truncl@PLT # TAILCALL
start:
  %0 = tail call fp128 @llvm.trunc.f128(fp128 %a)
  ret fp128 %0
}

declare fp128 @llvm.trunc.f128(fp128)
